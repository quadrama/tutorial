[
["index.html", "DramaAnalysis Preface", " DramaAnalysis Nils Reiter 2019-05-12 Preface This book is in alpha stadium and not ready. In pertains to the (currently unreleased version 3.0 of the DramaAnalysis package. Use at your own risk. "],
["introduction.html", "1 Introduction 1.1 Technical basics", " 1 Introduction In this book, we will introduce an interesting method. 1.1 Technical basics 1.1.1 Pipelining with margrittr 1.1.2 Classes "],
["data-preparations.html", "2 Data preparations", " 2 Data preparations # Load Emilia Galotti data(rksp.0) # Load Miß Sara Sampson data(rjmw.0) text &lt;- combine(rksp.0, rjmw.0) "],
["whos-talking-how-much.html", "3 Who’s talking how much? 3.1 Character names instead of identifiers 3.2 Stacked bar plot", " 3 Who’s talking how much? First, we calculate summary statistics over all characters. charStats &lt;- characterStatistics(text) charStats ## corpus drama character tokens types utterances ## 1 test rjmw.0 sir_william 2056 698 23 ## 2 test rjmw.0 waitwell 1826 568 41 ## 3 test rjmw.0 der_wirt 324 177 7 ## 4 test rjmw.0 mellefont 7981 1722 201 ## 5 test rjmw.0 norton 1001 407 46 ## 6 test rjmw.0 betty 482 223 20 ## 7 test rjmw.0 sara 9121 1908 166 ## 8 test rjmw.0 marwood 7225 1757 155 ## 9 test rjmw.0 hannah 258 155 16 ## 10 test rjmw.0 der_bediente 44 34 2 ## 11 test rjmw.0 arabella 398 162 13 ## 12 test rksp.0 der_prinz 5303 1257 157 ## 13 test rksp.0 der_kammerdiener 42 34 6 ## 14 test rksp.0 conti 764 325 24 ## 15 test rksp.0 marinelli 5567 1324 221 ## 16 test rksp.0 camillo_rota 106 62 6 ## 17 test rksp.0 claudia_galotti 2098 657 73 ## 18 test rksp.0 pirro 343 196 25 ## 19 test rksp.0 odoardo 3248 891 108 ## 20 test rksp.0 angelo 635 300 28 ## 21 test rksp.0 emilia 2275 630 64 ## 22 test rksp.0 appiani 1112 426 48 ## 23 test rksp.0 battista 195 112 11 ## 24 test rksp.0 orsina 2832 743 64 ## utteranceLengthMean utteranceLengthSd firstBegin lastEnd ## 1 89.39130 108.948169 597 170838 ## 2 44.53659 59.768762 670 158683 ## 3 46.28571 45.492543 3571 5695 ## 4 39.70647 50.034972 5848 170188 ## 5 21.76087 23.601492 6328 170456 ## 6 24.10000 36.404019 9014 156987 ## 7 54.94578 77.785973 11766 167457 ## 8 46.61290 62.383230 28320 141005 ## 9 16.12500 15.654073 28392 58523 ## 10 22.00000 12.727922 31532 31790 ## 11 30.61538 31.967532 43987 52559 ## 12 33.77707 40.807176 426 136067 ## 13 7.00000 5.215362 1149 24954 ## 14 31.83333 40.141778 2654 12212 ## 15 25.19005 29.844599 13147 134486 ## 16 17.66667 19.179851 25577 26914 ## 17 28.73973 29.131897 27006 112526 ## 18 13.72000 10.663489 27113 50425 ## 19 30.07407 40.399571 27385 135555 ## 20 22.67857 19.573326 28777 64877 ## 21 35.54688 48.159105 36769 134940 ## 22 23.16667 25.525401 44452 56735 ## 23 17.72727 32.948720 67465 86481 ## 24 44.25000 50.977119 88094 112182 This already gives us a lot of information about the characters. In particular, the function characterStatistics() returns a table (of the types QDCharacterStatistics, QDHasCharacter and data.frame) with information about: the number of tokens a character speaks (tokens), the number of different tokens a character speaks (types), the number of utterances (utterances), the average length of the utterances (utteranceLengthMean), their standard deviation (utteranceLengthSd), the character position of the start of the first utterance (firstBegin), and the character position of the end of the last utterance (lastEnd). The function characterStatistics() provides a number of options to control its exact behaviour. Entering ?characterStatistics in the R console opens the documentation for the function with a description of all the options. We’ll describe some frequently used options here as well: Punctuation: By default, all punctuation marks are counted as tokens. This behaviour can be changed by setting filterPunctuation=TRUE. Normalization: The values in the table above are all absolute values. When comparing to other texts, one is often interested in normalized values. If the option normalize is set to TRUE, all values will be normalised (if applicable). Segmentation: By default, the function extracts values for the entire play. With the option segment, it is possible to extract statistics by act or scene, as shown in the example below. Except for the additional column Act, the columns in the table are the same as before. characterStatistics(rksp.0, segment=&quot;Act&quot;) ## corpus drama Act character tokens types utterances ## 1 test rksp.0 I der_prinz 2740 795 71 ## 2 test rksp.0 I der_kammerdiener 42 34 6 ## 3 test rksp.0 I conti 764 325 24 ## 4 test rksp.0 I marinelli 1038 412 31 ## 5 test rksp.0 I camillo_rota 106 62 6 ## 6 test rksp.0 II claudia_galotti 1252 477 50 ## 7 test rksp.0 II pirro 343 196 25 ## 8 test rksp.0 II odoardo 611 295 17 ## 9 test rksp.0 II angelo 385 214 19 ## 10 test rksp.0 II emilia 1166 417 28 ## 11 test rksp.0 II appiani 1112 426 48 ## 12 test rksp.0 II marinelli 527 255 28 ## 13 test rksp.0 III marinelli 1814 605 56 ## 14 test rksp.0 III der_prinz 945 398 29 ## 15 test rksp.0 III angelo 250 147 9 ## 16 test rksp.0 III battista 187 106 9 ## 17 test rksp.0 III emilia 413 175 16 ## 18 test rksp.0 III claudia_galotti 614 241 16 ## 19 test rksp.0 IV der_prinz 803 319 30 ## 20 test rksp.0 IV marinelli 1358 495 72 ## 21 test rksp.0 IV battista 8 7 2 ## 22 test rksp.0 IV orsina 2832 743 64 ## 23 test rksp.0 IV odoardo 706 275 30 ## 24 test rksp.0 IV claudia_galotti 232 125 7 ## 25 test rksp.0 V marinelli 830 363 34 ## 26 test rksp.0 V der_prinz 815 321 27 ## 27 test rksp.0 V odoardo 1931 620 61 ## 28 test rksp.0 V emilia 696 251 20 ## utteranceLengthMean utteranceLengthSd firstBegin lastEnd ## 1 38.59155 39.891130 426 26559 ## 2 7.00000 5.215362 1149 24954 ## 3 31.83333 40.141778 2654 12212 ## 4 33.48387 34.234360 13147 23619 ## 5 17.66667 19.179851 25577 26914 ## 6 25.04000 28.927750 27006 56666 ## 7 13.72000 10.663489 27113 50425 ## 8 35.94118 41.800823 27385 36244 ## 9 20.26316 19.674694 28777 32436 ## 10 41.64286 63.826277 36769 48503 ## 11 23.16667 25.525401 44452 56735 ## 12 18.82143 17.346263 50431 55936 ## 13 32.39286 35.245982 56826 79337 ## 14 32.58621 48.327393 56914 72918 ## 15 27.77778 19.466495 63132 64877 ## 16 20.77778 36.033935 67465 75603 ## 17 25.81250 27.352559 67517 79537 ## 18 38.37500 28.765431 74777 79747 ## 19 26.76667 38.699268 79838 95409 ## 20 18.86111 20.750229 79972 103998 ## 21 4.00000 2.828427 86363 86481 ## 22 44.25000 50.977119 88094 112182 ## 23 23.53333 18.528140 101533 112733 ## 24 33.14286 29.952343 110037 112526 ## 25 24.41176 36.802600 112824 134486 ## 26 30.18519 37.235257 113752 136067 ## 27 31.65574 47.382094 114998 135555 ## 28 34.80000 34.284568 128910 134940 Of course, the values in the above table can be directly plotted: charStats &lt;- characterStatistics(text, normalize=FALSE) par(mar=c(9,3,2,2)) # increase plot margins, so that the labels can be plotted barplot(charStats$tokens, # these are the values to be plotted names.arg = charStats$character, # the labels on the x-axis las=2 # rotate the labels on both axes ) 3.1 Character names instead of identifiers By default, all our functions identify characters using technical ids, which may or may not be human-readable. Even if they are, it’s usually a good idea to replace them with nice to read labels before publication. We therefore provide the function format(), which can be applied to any table that contains a column with character ids (i.e., any object of type QDHasCharacter). charStats &lt;- characterStatistics(text, normalize=FALSE) charStats &lt;- format(charStats, text) # Replace ids with names par(mar=c(9,3,2,2)) # increase plot margins, so that the labels can be plotted barplot(charStats$tokens, # these are the values to be plotted names.arg = charStats$character, # the labels on the x-axis las=2 # rotate the labels on both axes ) As can be seen above format() requires two arguments: The table in which we want to replace ids by characters, and the original drama object (that we got from calling the function loadDrama()). 3.2 Stacked bar plot The plot shown above is quite wide, and some aspects (like the ranking in terms of spoken tokens), is hard to see. We often use another way of visualizing this, which can be used if you supply the QDCharacterStatistics directly into the barplot() function. In combination with the margrittr pipes, we can call it like this (enter ?barplot.QDCharacterStatistics for details on the special barplot function): characterStatistics(text, normalize=FALSE) %&gt;% format(text) %&gt;% barplot(names.arg=c(&quot;Miss Sara Sampson&quot;, &quot;Emilia Galotti&quot;)) By default, the barplot.QDCharacterStatistics() function visualises the number of tokens spoken by the characters (and ranks the characters accordingly). This can be changed by supplying the option column, and specifying another value. characterStatistics(text, normalize=FALSE) %&gt;% format(text) %&gt;% barplot(names.arg=c(&quot;Miss Sara Sampson&quot;, &quot;Emilia Galotti&quot;), column = &quot;utteranceLengthMean&quot;) # show mean utterance length This picture looks quite different! Other interesting columns to experiment with are types and utteranceLengthSd. "],
["whos-talking-how-often.html", "4 Who’s talking how often? 4.1 When are characters talking? 4.2 Adding act boundaries", " 4 Who’s talking how often? So far, we have counted words for characters. Now we will turn to utterances, and their properties. First, we will use the function utteranceStatistics() to extract quantitative information about utterances: utteranceStatistics(rksp.0) ## corpus drama character utteranceBegin utteranceLength ## 1 test rksp.0 der_prinz 426 3.874388e-03 ## 2 test rksp.0 der_kammerdiener 1149 8.156607e-05 ## 3 test rksp.0 der_prinz 1178 2.895595e-03 ## 4 test rksp.0 der_kammerdiener 1526 6.525285e-04 ## 5 test rksp.0 der_prinz 1655 2.854812e-04 ## 6 test rksp.0 der_kammerdiener 1697 1.631321e-04 ## 7 test rksp.0 der_prinz 1739 1.019576e-03 ## 8 test rksp.0 der_kammerdiener 1857 3.262643e-04 ## 9 test rksp.0 der_prinz 1919 2.528548e-03 ## 10 test rksp.0 der_kammerdiener 2299 3.670473e-04 This creates a table that is very long, which is why we only show the first 10 rows here. The table contains one row for each utterance, and information about the speaker of the utterance, its length (measured in tokens) and its starting position (character position). We can now inspect the variance in utterance length: ustat &lt;- utteranceStatistics(rksp.0) %&gt;% format(rksp.0) # use names instead of character ids (see above) par(mar=c(9,4,2,2)) # increase margin boxplot(utteranceLength ~ character, # what do we want to correlate data=ustat, las = 2 # rotate axis labels ) This uses the regular boxplot() function, enter ?boxplot for documentation. utteranceLength ~ character is called a formula in R and (in this case) expresses that we want to look at the column utteranceLength, grouped by the column character. The boxplot is a useful way to grasp the dispersion of a set of values (in this case: the lengths of all utterances by a character). 4.1 When are characters talking? While the above displays the length of utterances, we can also display the position of utterances (remember the column utteranceBegin?). The following snippet visualizes when characters are talking, this time for Lessings Miss Sara Sampson: par(mar=c(2,7,2,2)) utteranceStatistics(rjmw.0) %&gt;% format(rjmw.0) %&gt;% # character names instead of ids plot() # calling plot.QDUtteranceStatistics() Each dot in this plot represents one utterance, the x-axis is measured in character positions. This is not really intuitive, but the flow from left to right represents the flow of the text. More technically, we again apply the function format() to display character names instead of character ids. This is the same function as above, just applied to a different table. It can be applied to any table of the type QDHasCharacter. Secondly, the call to the function plot() gets rerouted to the function plot.QDUtteranceStatistics(), because the object we supply as argument is of the type QDUtteranceStatistics. Information about this function can be retrieved by entering ?plot.QDUtteranceStatistics. 4.2 Adding act boundaries Now it would be useful to include information on act/scene boundaries in this plot. This can be done by supplying the original drama object as a second argument to the plot() function: par(mar=c(2,8,2,2)) utteranceStatistics(rksp.0) %&gt;% format(rksp.0) %&gt;% plot(rksp.0) # adding the `QDDrama` object here creates the act boundaries. Please note that the information contained in this plot is very similar to the information in configuration matrices. "],
["configuration.html", "5 Configuration 5.1 Matrices 5.2 Copresence", " 5 Configuration This section does not refer to the configuration of the R-package, but to the literary analysis concept configuration matrix (Pfister 1988). 5.1 Matrices Configuration matrices can be extracted with the function configuration(). As usual, entering ?configuration provies more detailed information about the options the function provides. configuration(rksp.0) ## corpus drama character 1 2 3 4 5 ## 1 test rksp.0 der_prinz 2740 0 945 803 815 ## 2 test rksp.0 der_kammerdiener 42 0 0 0 0 ## 3 test rksp.0 conti 764 0 0 0 0 ## 4 test rksp.0 marinelli 1038 527 1814 1358 830 ## 5 test rksp.0 camillo_rota 106 0 0 0 0 ## 6 test rksp.0 claudia_galotti 0 1252 614 232 0 ## 7 test rksp.0 pirro 0 343 0 0 0 ## 8 test rksp.0 odoardo 0 611 0 706 1931 ## 9 test rksp.0 angelo 0 385 250 0 0 ## 10 test rksp.0 emilia 0 1166 413 0 696 ## 11 test rksp.0 appiani 0 1112 0 0 0 ## 16 test rksp.0 battista 0 0 187 8 0 ## 22 test rksp.0 orsina 0 0 0 2832 0 This creates a basic configuration matrix, but instead of just containing the presence or absence of a figure, it contains the number of spoken tokens for each act for each character. This information is in fact similar to what we can extract with characterStatistics(rksp.0, segment=\"Act\"), but in a different form and structure. The above table contains a lot of information that can be visualised. We first need to extract the numeric content from the above table. This can easily be done with the function as.matrix() (this will, in detail, be rerouted to the function as.matrix.QDConfiguration(), which knows what part of the table needs to be in the matrix). A matrix containing only numbers can easily be plotted using the regular barplot() function, as shown below. c &lt;- configuration(rksp.0) mat &lt;- as.matrix(c) par(mar=c(2,2,2,10)) barplot(mat, legend.text = c$character, # legend text args.legend = list(x=ncol(mat)+3, # legend x position y=max(colSums(mat)) # legend y pos ), col=qd.colors) 5.1.1 Filtering unimportant characters This is informative, but doesn’t look very nice and some colors are difficult to associate with characters because colors are repeating. We will therefore use the function filter(), which is very similar to format(): It can be applied to any object of the type QDHasCharacter and removes rows according to certain criteria. In this case, we filter every character except the five most talkative ones. As usual, see ?filter.QDHasCharacter to see other options. c &lt;- configuration(rksp.0) %&gt;% filter(rksp.0, threshold = 5) %&gt;% format(rksp.0) mat &lt;- as.matrix(c) par(mar=c(2,2,2,10)) barplot(mat, names.arg = as.roman(1:ncol(mat)), # roman act numbers legend.text = c$character, # legend text args.legend = list(x=ncol(mat)+3, # legend x position y=max(colSums(mat)) # legend y pos ), col=qd.colors) Of course, the speech of characters that do not speak often is now removed, leaving only a portion of each act covered in the plot. 5.1.2 Normalization Since each act has a different length, it is often useful to normalize each block, according to the total number of spoken tokens. This way, we can display the relative active presence of each character in each act. In combination with the filtering we did before, however, we need to be careful: If the scale with the filtered matrix, a certain portion of the character speech gets lost. The following snippet shows how to scale using the original matrix, but still only include the top eight characters into the matrix. c &lt;- configuration(rksp.0) # getting the full configuration (with all characters) mat_orig &lt;- as.matrix(c) # extracting the matrix c_filtered &lt;- c %&gt;% filter(rksp.0, threshold=8) # filtering, so that only the top 8 characters remain mat_filtered &lt;- as.matrix(c_filtered) # extracting the filtered matrix # scaling, using values from the unfiltered matrix mat &lt;- scale(mat_filtered, center=FALSE, scale=colSums(mat_orig)) # plot, as above par(mar=c(2,3,2,10)) barplot(mat, names.arg = as.roman(1:ncol(mat)), # roman act numbers # legend legend.text=c_filtered$character, # set legend text args.legend = list(x=ncol(mat)+3, # legend x position y=max(colSums(mat)) # legend y pos ), # visual las=1, # rotate labels on y axis col=qd.colors # provide colors ) 5.2 Copresence Configuration matrices are also often used to get an overview of who is copresent on stage. This can also be achieved using the function configuration(). First, we create a configuration matrix that only represents presence or absence of a figure (and we switch to scenes). Obviously, the resulting matrix has many more columns, we include only the first 10 below. configuration(rksp.0, onlyPresence = TRUE, segment=&quot;Scene&quot;) ## corpus drama character 1 2 3 4 5 6 ## 1 test rksp.0 der_prinz TRUE TRUE TRUE TRUE TRUE TRUE ## 2 test rksp.0 der_kammerdiener TRUE FALSE FALSE FALSE FALSE FALSE ## 4 test rksp.0 conti FALSE TRUE FALSE TRUE FALSE FALSE ## 9 test rksp.0 marinelli FALSE FALSE FALSE FALSE FALSE TRUE ## 14 test rksp.0 camillo_rota FALSE FALSE FALSE FALSE FALSE FALSE ## 15 test rksp.0 claudia_galotti FALSE FALSE FALSE FALSE FALSE FALSE ## 16 test rksp.0 pirro FALSE FALSE FALSE FALSE FALSE FALSE ## 17 test rksp.0 odoardo FALSE FALSE FALSE FALSE FALSE FALSE ## 20 test rksp.0 angelo FALSE FALSE FALSE FALSE FALSE FALSE ## 25 test rksp.0 emilia FALSE FALSE FALSE FALSE FALSE FALSE ## 27 test rksp.0 appiani FALSE FALSE FALSE FALSE FALSE FALSE ## 47 test rksp.0 battista FALSE FALSE FALSE FALSE FALSE FALSE ## 65 test rksp.0 orsina FALSE FALSE FALSE FALSE FALSE FALSE ## 7 ## 1 TRUE ## 2 TRUE ## 4 FALSE ## 9 FALSE ## 14 FALSE ## 15 FALSE ## 16 FALSE ## 17 FALSE ## 20 FALSE ## 25 FALSE ## 27 FALSE ## 47 FALSE ## 65 FALSE Creating a co-occurrence matrix is a simple matter of matrix multiplication, and we already know how to create a matrix. # extract the configuration c &lt;- configuration(rksp.0, onlyPresence = TRUE, segment=&quot;Scene&quot;) # extract a matrix mat &lt;- as.matrix(c) # multiply the matrix with its inverse # this creates the copresence matrix copresence &lt;- mat %*% t(mat) # add character names rownames(copresence) &lt;- c$character colnames(copresence) &lt;- c$character copresence ## der_prinz der_kammerdiener conti marinelli camillo_rota ## der_prinz 17 2 2 9 1 ## der_kammerdiener 2 2 0 0 0 ## conti 2 0 2 0 0 ## marinelli 9 0 0 19 0 ## camillo_rota 1 0 0 0 1 ## claudia_galotti 0 0 0 3 0 ## pirro 0 0 0 1 0 ## odoardo 2 0 0 4 0 ## angelo 0 0 0 1 0 ## emilia 2 0 0 4 0 ## appiani 0 0 0 2 0 ## battista 1 0 0 3 0 ## orsina 1 0 0 3 0 ## claudia_galotti pirro odoardo angelo emilia appiani ## der_prinz 0 0 2 0 2 0 ## der_kammerdiener 0 0 0 0 0 0 ## conti 0 0 0 0 0 0 ## marinelli 3 1 4 1 4 2 ## camillo_rota 0 0 0 0 0 0 ## claudia_galotti 13 3 3 0 3 4 ## pirro 3 4 1 1 0 1 ## odoardo 3 1 12 0 2 0 ## angelo 0 1 0 2 0 0 ## emilia 3 0 2 0 7 1 ## appiani 4 1 0 0 1 5 ## battista 2 0 0 0 1 0 ## orsina 1 0 3 0 0 0 ## battista orsina ## der_prinz 1 1 ## der_kammerdiener 0 0 ## conti 0 0 ## marinelli 3 3 ## camillo_rota 0 0 ## claudia_galotti 2 1 ## pirro 0 0 ## odoardo 0 3 ## angelo 0 0 ## emilia 1 0 ## appiani 0 0 ## battista 4 0 ## orsina 0 6 The resulting copresence matrix shows the number of scenes in which two characters are both present. The diagonal shows the number of scenes in which a character is present in total (because each character is always copresent with itself, so to speak). There are multiple ways to visualise this copresence. One option is a heat map, as shown below. 5.2.1 As Heatmap The copresence can be visualised in a simple heat map. We first focus on the lower triangle and also remove the diagonal values. The actual plotting is a bit more complicated in this case, because we are just using the values in the copresence matrix as pixel intensities in the plot. Also, the axes need to be suppressed first, and can be added later with the proper names of the characters. If needed the code can also be used to include labels into the heat map. c &lt;- configuration(rksp.0, onlyPresence = TRUE, segment=&quot;Scene&quot;) %&gt;% filter(rksp.0, threshold = 7) %&gt;% format(rksp.0) # extract a matrix mat &lt;- as.matrix(c) # multiply the matrix with its inverse # this creates the copresence matrix copresence &lt;- mat %*% t(mat) # add character names rownames(copresence) &lt;- c$character colnames(copresence) &lt;- c$character # since it&#39;s a square matrix, we don&#39;t need the bottom right triangle # and diagonales. copresence[lower.tri(copresence,diag=TRUE)] &lt;- NA par(mar=c(10,10,1,1)) # plot margins image(copresence, col = rgb(256,111,184, alpha=(seq(0,255)), maxColorValue = 256), xaxt= &quot;n&quot;, # no x axis yaxt= &quot;n&quot;, # no y axis frame=TRUE # print a frame around the heatmap ) # include values as labels text(y=(rep(1:ncol(copresence), each=nrow(copresence))-1)/(nrow(copresence)-1), x=(1:nrow(copresence)-1)/(nrow(copresence)-1), labels=as.vector(copresence)) # add the x axis axis(1, at = seq(0,1,length.out = length(c$character)), labels = c$character, las=3) # add the y axis axis(2, at = seq(0,1,length.out = length(c$character)), labels = c$character, las=1) Apparently, Marinelli and the prince have the most shared scenes. Marinelli also shares a scene with most other figures (sum of the vertical bar: 16). 5.2.2 As Network The same information can also be visualized as a copresence network. For this, we employ the R-package igraph. A nice introduction to igraph can be found in (Arnold and Tilton 2015), particularly for literary networks. Technically, the matrix we created before is an adjacency matrix. It is therefore simple to convert it to a graph, and igraph offers the function graph_from_adjacency_matrix() for this. c &lt;- configuration(rksp.0, onlyPresence = TRUE, segment=&quot;Scene&quot;) %&gt;% filter(rksp.0, threshold = 7) %&gt;% format(rksp.0) # extract a matrix mat &lt;- as.matrix(c) # multiply the matrix with its inverse # this creates the copresence matrix copresence &lt;- mat %*% t(mat) # add character names rownames(copresence) &lt;- c$character colnames(copresence) &lt;- c$character # convert the adjacency matrix to a graph object g &lt;- igraph::graph_from_adjacency_matrix(copresence, weighted=TRUE, # weighted graph mode=&quot;undirected&quot;, # no direction diag=FALSE # no looping edges ) Now the variable g holds the graph object. There are different things we can do with the graph. First, we can visualise it. igraph uses the same mechanism of R that we have used before for plotting, specifying a plot() function that can plot graph objects. # Now we plot plot(g, layout=layout_with_gem, # how to lay out the graph main=&quot;Copresence Network: Emilia Galotti&quot;, # title vertex.label.cex=0.8, # label size vertex.label.color=&quot;black&quot;, # font color vertex.color=qd.colors[6], # vertex color vertex.frame.color=NA, # no vertex border edge.width=E(g)$weight # scale edges according to their weight ) 5.2.3 Network properties igraph offers a number of function to extract graph properties. We will show them below without explanation. The documentation of each function can be found here. 5.2.3.1 Density Function: graph.density() graph.density(g) ## [1] 0.7619048 5.2.3.2 Average nearest neighbor degree Function: knn() knn(g) ## $knn ## Der Prinz Marinelli Claudia Odoardo Galotti ## 4.214286 2.760000 4.714286 5.214286 ## Emilia Appiani Orsina ## 6.166667 7.285714 8.375000 ## ## $knnk ## [1] NaN NaN 7.285714 6.294643 5.365079 2.760000 5.2.3.3 Edge connectivity Function: edge_connectivity() edge_connectivity(g) ## [1] 3 5.2.4 Graph Export As a final step, one might want to further work on the graph using Gephi, or other tools. In order to do so, one can export the graph into an appropriate file: igraph::write_graph(g, &quot;rksp.0.graphml&quot;, # specify the file name format=&quot;graphml&quot; # specify the file format ) This results in a file called rksp.0.graphml, that starts similarly as this: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;graphml xmlns=&quot;http://graphml.graphdrawing.org/xmlns&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd&quot;&gt; &lt;!-- Created by igraph --&gt; &lt;key id=&quot;v_name&quot; for=&quot;node&quot; attr.name=&quot;name&quot; attr.type=&quot;string&quot;/&gt; &lt;key id=&quot;e_weight&quot; for=&quot;edge&quot; attr.name=&quot;weight&quot; attr.type=&quot;double&quot;/&gt; &lt;graph id=&quot;G&quot; edgedefault=&quot;undirected&quot;&gt; &lt;node id=&quot;n0&quot;&gt; &lt;data key=&quot;v_name&quot;&gt;DER KAMMERDIENER&lt;/data&gt; &lt;/node&gt; &lt;node id=&quot;n1&quot;&gt; &lt;data key=&quot;v_name&quot;&gt;DER PRINZ&lt;/data&gt; &lt;/node&gt; ... This file can be opened with Gephi. "],
["word-field-analysis.html", "6 Word Field Analysis", " 6 Word Field Analysis "],
["advanced-text-analysis.html", "7 Advanced Text Analysis 7.1 When are characters mentioned?", " 7 Advanced Text Analysis 7.1 When are characters mentioned? When characters are speaking on stage, they are actively present. But they can also be passively present, if other characters refer to them. Both levels of presence can be extracted with the presence() function: # Load Emilia Galotti data(rksp.0) pres &lt;- presence(rksp.0) pres ## corpus drama character scenes actives passives presence ## 1 test rksp.0 angelo 43 2 1 0.02325581 ## 2 test rksp.0 appiani 43 5 14 -0.20930233 ## 3 test rksp.0 battista 43 4 6 -0.04651163 ## 4 test rksp.0 camillo_rota 43 1 2 -0.02325581 ## 5 test rksp.0 claudia_galotti 43 13 14 -0.02325581 ## 6 test rksp.0 conti 43 1 3 -0.04651163 ## 7 test rksp.0 der_kammerdiener 43 1 2 -0.02325581 ## 8 test rksp.0 der_prinz 43 14 21 -0.16279070 ## 9 test rksp.0 emilia 43 7 21 -0.32558140 ## 10 test rksp.0 marinelli 43 19 21 -0.04651163 ## 11 test rksp.0 odoardo 43 12 11 0.02325581 ## 12 test rksp.0 orsina 43 6 10 -0.09302326 ## 13 test rksp.0 pirro 43 4 5 -0.02325581 As we can see, each character has a few numbers associated: The column actives shows the number of scenes in which the character is actively present. This is equivalent to the information in the configuration matrix. The column passives shows the number of scenes in which a character is mentioned. By default, this excludes the scenes in which they are present themselves (this behaviour can be changed by adding the parameter passiveOnlyWhenNotActive = TRUE to the call of the presence function). A simple visualisation that shows the characters active and passive presence in one plot can be generated like this: The first line (plot()) is responsible for the plotting of the symbols, the second line (text()) adds the character names or ids numbers. plot(x=pres$active/pres$scenes, y=pres$passive/pres$scenes, xlim=c(0,1), ylim=c(0,1), xlab=&quot;Active&quot;, ylab=&quot;Passive&quot;, main=&quot;Character Presence&quot;) text(x=pres$actives/pres$scenes, y=pres$passives/pres$scenes, labels=substr(pres$character,0,20), pos=3) "],
["resterampe.html", "8 Resterampe", " 8 Resterampe 8.0.1 Character meta data We will now combine this information with additional meta data about characters, i.e., gender. # Proportion of male / female characters barplot(table(text$characters$Gender),col=qd.colors) 8.0.2 Character groups Next, we want to make the same analysis not for individual characters, but for character groups, based on categories such as gender. ustat &lt;- utteranceStatistics(rjmw.0, normalizeByDramaLength = FALSE # use absolute values ) characterdata &lt;- rjmw.0$characters ustat &lt;- merge(ustat, characterdata, by.x = c(&quot;corpus&quot;,&quot;drama&quot;, &quot;character&quot;), by.y = c(&quot;corpus&quot;,&quot;drama&quot;, &quot;figure_id&quot;)) par(mar=c(2,2,2,2)) boxplot(utteranceLength ~ Gender, # what do we want to correlate data=ustat, las = 1 # rotate axis labels ) According to this picture, female characters speak slightly longer utterances in this play. "],
["references.html", "References", " References "]
]
